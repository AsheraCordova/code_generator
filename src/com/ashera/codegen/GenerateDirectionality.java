//start - license
/*
 * Copyright (c) 2025 Ashera Cordova
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
//end - license
package com.ashera.codegen;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class GenerateDirectionality {

    static class Range {
        final int start, end;
        Range(int s, int e) { start = s; end = e; }
    }

    public static void main(String[] args) throws IOException {
        final int MAX = Character.MAX_CODE_POINT; // 0x10FFFF
        Map<Byte, List<Range>> dirMap = new LinkedHashMap<>();

        int start = 0;
        byte current = Character.getDirectionality(0);

        // Build minimal ranges of contiguous identical directionality
        for (int i = 1; i <= MAX; i++) {
            if (i == 0xD800) { // skip surrogate range
                addRange(dirMap, current, start, 0xD7FF);
                i = 0xE000;
                if (i > MAX) break;
                start = i;
                current = Character.getDirectionality(i);
                continue;
            }

            byte dir = Character.getDirectionality(i);
            if (dir != current) {
                addRange(dirMap, current, start, i - 1);
                start = i;
                current = dir;
            }
        }
        addRange(dirMap, current, start, MAX);

        // Write the generated file
        try (StringWriter out = new StringWriter())  {
            out.write("/**\n");
            out.write(" * Auto-generated directionality lookup using grouped if-else conditions.\n");
            out.write(" * Generated by GenerateDirectionalityMap.java\n");
            out.write(" */\n\n");
            out.write("public class GeneratedDirectionalityMap {\n");
            out.write("    //start - getDirectionality\n");
            out.write("    public static byte getDirectionality(int cp) {\n");

            boolean firstBlock = true;
            for (Map.Entry<Byte, List<Range>> entry : dirMap.entrySet()) {
                byte dir = entry.getKey();
                List<Range> ranges = entry.getValue();

                if (firstBlock) {
                	out.write(String.format("        %s (", "if"));
                } else {
                	out.write(String.format(" %s (", "else if"));
                }
                firstBlock = false;

                // join all ranges with " || "
                for (int i = 0; i < ranges.size(); i++) {
                    Range r = ranges.get(i);
                    if (i > 0) out.write("\n         || ");
                    if (r.start == r.end) {
                        out.write(String.format("cp == 0x%04X", r.start));
                    } else {
                        out.write(String.format("(cp >= 0x%04X && cp <= 0x%04X)", r.start, r.end));
                    }
                }

                out.write(String.format(") {\n            return (byte) %d;\n        }", dir));
            }

            out.write("\n        return Character.DIRECTIONALITY_UNDEFINED;\n");
            out.write("    }\n");
            out.write("    //end - getDirectionality\n");
            out.write("}\n");
            writeOrUpdateFile(out.toString(), "D:\\Java\\git\\core-web-widget\\teavvm\\classlib\\src\\main\\java\\org\\teavm\\classlib\\java\\lang\\TCharacter.java", "getDirectionality");
            System.out.println(out.toString());
        }

    }
    
	public static void writeOrUpdateFile(String code, String pathname, boolean force, HashMap<String, String> codeCopyMap,
			String... keyWords) throws IOException {
		
		writeOrUpdateFileInternal(code, pathname, force, codeCopyMap, "start - ", "end - ", false, keyWords);		
		
	}

    private static void addRange(Map<Byte, List<Range>> map, byte dir, int start, int end) {
        map.computeIfAbsent(dir, k -> new ArrayList<>()).add(new Range(start, end));
    }
    
	public static void writeOrUpdateFile(String code, String pathname, 
			String... keyWords) throws IOException { 
		writeOrUpdateFile(code, pathname, false, null, keyWords);
	}
    
	public static String readFileToString(File filePath) throws IOException {
		StringBuilder fileData = new StringBuilder(1000);
		System.out.println(filePath.getAbsolutePath());
		BufferedReader reader = new BufferedReader(new FileReader(filePath));
 
		char[] buf = new char[10];
		int numRead = 0;
		while ((numRead = reader.read(buf)) != -1) {
			String readData = String.valueOf(buf, 0, numRead);
			fileData.append(readData);
			buf = new char[1024];
		} 
 
		reader.close();
 
		return  fileData.toString();	
	}
    
    private static void writeOrUpdateFileInternal(String code, String pathname, boolean force,
			HashMap<String, String> codeCopyMap, String startPrefix, String endPrefix, boolean useSuffix, String... keyWords)
			throws IOException {
		File file = new File(pathname);
		if (!file.exists() || force) {
			file.getParentFile().mkdirs();
		    writeToFile(file, code);
		} else {
			String originalFile = readFileToString(file);
			String finalStr = "";
			for (int j = 0; j < keyWords.length; j++) {
		    	String keyword = keyWords[j];

				String startKeyWord = startPrefix + keyword;
		    	String endKeyWord = endPrefix + keyword;
		    	
		    	if (useSuffix) {
		    		endKeyWord = keyword + endPrefix;
		    	}

				
				int startOrig = originalFile.indexOf(startKeyWord);
				int endOrig = originalFile.indexOf(endKeyWord);
		    	int  startFinal = code.indexOf(startKeyWord);
		    	int endFinal = code.indexOf(endKeyWord);
		    	if (startOrig != -1) {
		        	finalStr = originalFile.substring(0, startOrig) +
		        			code.substring(startFinal, endFinal) +
		        			originalFile.substring(endOrig, originalFile.length());
		        	originalFile = finalStr;
		    	} else {
		    		finalStr = originalFile;
		    	}
			}
			if (codeCopyMap != null) {
				Iterator<String> keys = codeCopyMap.keySet().iterator();
				while (keys.hasNext()) {
					String key = keys.next();
					String start = startPrefix + key;
					String end = endPrefix + key;
			    	if (useSuffix) {
			    		end = key + endPrefix;
			    	}
					
					int  startFinal = finalStr.indexOf(start) + start.length();
			    	int endFinal = finalStr.indexOf(end) - 2;
			    	if (startFinal > endFinal) {
			    	    throw new RuntimeException();
			    	}
					finalStr = finalStr.substring(0, startFinal) + codeCopyMap.get(key) +finalStr.substring(endFinal, finalStr.length());
				}
			}
			
		    writeToFile(file, finalStr);
		}
	}


    public static void writeToFile(File file, String finalStr) throws IOException {
    	File parentFile = file.getParentFile();
    	if (parentFile != null) {
    		parentFile.mkdirs();
    	}
        FileWriter fis = new FileWriter(file);
        fis.write(finalStr);
        fis.close();
    }
}
