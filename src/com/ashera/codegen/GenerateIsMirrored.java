//start - license
/*
 * Copyright (c) 2025 Ashera Cordova
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
//end - license
package com.ashera.codegen;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.util.*;

public class GenerateIsMirrored {

    static class Range {
        final int start, end;
        Range(int s, int e) { start = s; end = e; }
    }

    public static void main(String[] args) throws IOException {
        final int MAX = Character.MAX_CODE_POINT; // U+10FFFF
        List<Range> mirrored = new ArrayList<>();

        // Build contiguous ranges of mirrored characters
        boolean current = Character.isMirrored(0);
        int start = 0;

        for (int i = 1; i <= MAX; i++) {
            // skip surrogate range
            if (i == 0xD800) {
                if (current) mirrored.add(new Range(start, 0xD7FF));
                i = 0xE000;
                if (i > MAX) break;
                start = i;
                current = Character.isMirrored(i);
                continue;
            }

            boolean isM = Character.isMirrored(i);
            if (isM != current) {
                if (current) mirrored.add(new Range(start, i - 1));
                start = i;
                current = isM;
            }
        }
        if (current) mirrored.add(new Range(start, MAX));

        // Write generated file
        try (StringWriter out = new StringWriter()) {
            out.write("/**\n");
            out.write(" * Auto-generated mirror lookup using grouped if-else conditions.\n");
            out.write(" * Generated by GenerateIsMirroredMap.java\n");
            out.write(" */\n\n");
            out.write("public class GeneratedIsMirroredMap {\n");
            out.write("    //start - isMirrored\n");
            out.write("    public static boolean isMirrored(int cp) {\n");

            if (!mirrored.isEmpty()) {
                out.write("        if (");
                for (int i = 0; i < mirrored.size(); i++) {
                    Range r = mirrored.get(i);
                    if (i > 0) out.write("\n         || ");
                    if (r.start == r.end)
                        out.write(String.format("cp == 0x%04X", r.start));
                    else
                        out.write(String.format("(cp >= 0x%04X && cp <= 0x%04X)", r.start, r.end));
                }
                out.write(") {\n            return true;\n        }\n");
            }

            out.write("        return false;\n");
            out.write("    }\n");
            out.write("    //end - isMirrored\n");
            out.write("}\n");
            writeOrUpdateFile(out.toString(), "D:\\Java\\git\\core-web-widget\\teavvm\\classlib\\src\\main\\java\\org\\teavm\\classlib\\java\\lang\\TCharacter.java", "isMirrored");
        }

        System.out.println("? GeneratedIsMirroredMap.java created successfully.");
    }
    
    public static void writeOrUpdateFile(String code, String pathname, boolean force, HashMap<String, String> codeCopyMap,
			String... keyWords) throws IOException {
		
		writeOrUpdateFileInternal(code, pathname, force, codeCopyMap, "start - ", "end - ", false, keyWords);		
		
	}

    private static void addRange(Map<Byte, List<Range>> map, byte dir, int start, int end) {
        map.computeIfAbsent(dir, k -> new ArrayList<>()).add(new Range(start, end));
    }
    
	public static void writeOrUpdateFile(String code, String pathname, 
			String... keyWords) throws IOException { 
		writeOrUpdateFile(code, pathname, false, null, keyWords);
	}
    
	public static String readFileToString(File filePath) throws IOException {
		StringBuilder fileData = new StringBuilder(1000);
		System.out.println(filePath.getAbsolutePath());
		BufferedReader reader = new BufferedReader(new FileReader(filePath));
 
		char[] buf = new char[10];
		int numRead = 0;
		while ((numRead = reader.read(buf)) != -1) {
			String readData = String.valueOf(buf, 0, numRead);
			fileData.append(readData);
			buf = new char[1024];
		} 
 
		reader.close();
 
		return  fileData.toString();	
	}
    
    private static void writeOrUpdateFileInternal(String code, String pathname, boolean force,
			HashMap<String, String> codeCopyMap, String startPrefix, String endPrefix, boolean useSuffix, String... keyWords)
			throws IOException {
		File file = new File(pathname);
		if (!file.exists() || force) {
			file.getParentFile().mkdirs();
		    writeToFile(file, code);
		} else {
			String originalFile = readFileToString(file);
			String finalStr = "";
			for (int j = 0; j < keyWords.length; j++) {
		    	String keyword = keyWords[j];

				String startKeyWord = startPrefix + keyword;
		    	String endKeyWord = endPrefix + keyword;
		    	
		    	if (useSuffix) {
		    		endKeyWord = keyword + endPrefix;
		    	}

				
				int startOrig = originalFile.indexOf(startKeyWord);
				int endOrig = originalFile.indexOf(endKeyWord);
		    	int  startFinal = code.indexOf(startKeyWord);
		    	int endFinal = code.indexOf(endKeyWord);
		    	if (startOrig != -1) {
		        	finalStr = originalFile.substring(0, startOrig) +
		        			code.substring(startFinal, endFinal) +
		        			originalFile.substring(endOrig, originalFile.length());
		        	originalFile = finalStr;
		    	} else {
		    		finalStr = originalFile;
		    	}
			}
			if (codeCopyMap != null) {
				Iterator<String> keys = codeCopyMap.keySet().iterator();
				while (keys.hasNext()) {
					String key = keys.next();
					String start = startPrefix + key;
					String end = endPrefix + key;
			    	if (useSuffix) {
			    		end = key + endPrefix;
			    	}
					
					int  startFinal = finalStr.indexOf(start) + start.length();
			    	int endFinal = finalStr.indexOf(end) - 2;
			    	if (startFinal > endFinal) {
			    	    throw new RuntimeException();
			    	}
					finalStr = finalStr.substring(0, startFinal) + codeCopyMap.get(key) +finalStr.substring(endFinal, finalStr.length());
				}
			}
			
		    writeToFile(file, finalStr);
		}
	}


    public static void writeToFile(File file, String finalStr) throws IOException {
    	File parentFile = file.getParentFile();
    	if (parentFile != null) {
    		parentFile.mkdirs();
    	}
        FileWriter fis = new FileWriter(file);
        fis.write(finalStr);
        fis.close();
    }
}
