class View {
	private Object mCurrentAnimation;
	private View mGhostView = null;
	protected RenderNode mRenderNode = new RenderNode();
	private int verticalScrollbarWidth;
	private int horizontalScrollbarHeight;
	
	public View() {
		mViewFlags = SOUND_EFFECTS_ENABLED | HAPTIC_FEEDBACK_ENABLED;
		// Set some flags defaults
		mPrivateFlags2 = (LAYOUT_DIRECTION_DEFAULT << PFLAG2_LAYOUT_DIRECTION_MASK_SHIFT)
				| (TEXT_DIRECTION_DEFAULT << PFLAG2_TEXT_DIRECTION_MASK_SHIFT)
				| (PFLAG2_TEXT_DIRECTION_RESOLVED_DEFAULT)
				| (TEXT_ALIGNMENT_DEFAULT << PFLAG2_TEXT_ALIGNMENT_MASK_SHIFT)
				| (PFLAG2_TEXT_ALIGNMENT_RESOLVED_DEFAULT)
				| (IMPORTANT_FOR_ACCESSIBILITY_DEFAULT << PFLAG2_IMPORTANT_FOR_ACCESSIBILITY_SHIFT);
	}


protected void onDraw(  r.android.graphics.Canvas canvas){
}
public r.android.content.res.Resources getResources() {
	return new r.android.content.res.Resources();
}
public boolean isInEditMode() {
	return false;
}
public float getAlpha() {
	// TODO Auto-generated method stub
	return 0;
}
public float getRotation() {
	// TODO Auto-generated method stub
	return 0;
}
public float getRotationX() {
	// TODO Auto-generated method stub
	return 0;
}
public float getRotationY() {
	// TODO Auto-generated method stub
	return 0;
}
public float getScaleX() {
	// TODO Auto-generated method stub
	return 0;
}
public float getScaleY() {
	// TODO Auto-generated method stub
	return 0;
}
public float getPivotX() {
	// TODO Auto-generated method stub
	return 0;
}
public float getPivotY() {
	// TODO Auto-generated method stub
	return 0;
}
public float getTranslationX() {
	// TODO Auto-generated method stub
	return 0;
}
public float getTranslationY() {
	// TODO Auto-generated method stub
	return 0;
}
public float getTranslationZ() {
	// TODO Auto-generated method stub
	return 0;
}
public float getElevation() {
	// TODO Auto-generated method stub
	return 0;
}

public void setAlpha(float alpha) {
	// TODO Auto-generated method stub
	
}
public void setRotation(float rotation) {
	// TODO Auto-generated method stub
	
}
public void setRotationX(float rotationX) {
	// TODO Auto-generated method stub
	
}
public void setRotationY(float rotationY) {
	// TODO Auto-generated method stub
	
}
public void setScaleX(float scaleX) {
	// TODO Auto-generated method stub
	
}
public void setScaleY(float scaleY) {
	// TODO Auto-generated method stub
	
}
public void setPivotX(float transformPivotX) {
	// TODO Auto-generated method stub
	
}
public void setPivotY(float transformPivotY) {
	// TODO Auto-generated method stub
	
}
public void setTranslationX(float translationX) {
	// TODO Auto-generated method stub
	
}
public void setTranslationY(float translationY) {
	// TODO Auto-generated method stub
	
}
public void setTranslationZ(float translationZ) {
	// TODO Auto-generated method stub
	
}
public void setElevation(float elevation) {
	// TODO Auto-generated method stub
	
}

public boolean hasUnhandledKeyListener() {
    // TODO Auto-generated method stub
    return false;
}
public boolean hasDefaultFocus() {
    // TODO Auto-generated method stub
    return false;
}
void clearFocusInternal(  View focused,  boolean propagate,  boolean refocus){
}	

private boolean restoreDefaultFocus() {
    // TODO Auto-generated method stub
    return false;
}
private void notifyEnterOrExitForAutoFillIfNeeded(boolean b) {
    // TODO Auto-generated method stub
    
}
public boolean shouldDrawRoundScrollbar() {
	return false;
}	
public void setBackgroundColor(int backgroundColor) {
	// TODO Auto-generated method stub
	
}
public void requestFocusFromTouch() {
	// TODO Auto-generated method stub
	
}
public boolean requestFocus() {
	return false;
	
}
public void setSystemUiVisibility(int uiOptions) {
	// TODO Auto-generated method stub
	
}
public void setOverScrollMode(int overScrollNever) {
	// TODO Auto-generated method stub
	
}
	public void cancelPendingInputEvents() {
	}		
	public int getVerticalScrollbarWidth() {
		return this.verticalScrollbarWidth;
	}
	
	public void setVerticalScrollbarWidth(int verticalScrollbarWidth) {
		this.verticalScrollbarWidth = verticalScrollbarWidth;
	}
	
	public int getHorizontalScrollbarHeight() {
		return this.horizontalScrollbarHeight;
	}
	
	public void setHorizontalScrollbarHeight(int horizontalScrollbarHeight) {
		this.horizontalScrollbarHeight = horizontalScrollbarHeight;
	}

      private float getFinalAlpha() {
        return 1;
    }
    
    	void setFlags(int flags, int mask) {

		int old = mViewFlags;
		mViewFlags = (mViewFlags & ~mask) | (flags & mask);
		int changed = mViewFlags ^ old;
		if (changed == 0) {
			return;
		}
		int privateFlags = mPrivateFlags;
		
	}	
	
	public void invalidateOutline(){
	}
	
	public boolean isHardwareAccelerated() {
		return false;
	}
	public int getZ() {
		return 0;
	}
    
    void damageShadowReceiver() {
    }
    void damageInParent(){
    }
    
      private boolean hasRtlSupport(){
    return true;
  }
  private boolean isRtlCompatibilityMode(){
    return !hasRtlSupport();
  }
  
  public void notifySubtreeAccessibilityStateChangedIfNeeded() {
  }
  
  private void sizeChange(int newWidth,int newHeight,int oldWidth,int oldHeight){
	onSizeChanged(newWidth,newHeight,oldWidth,oldHeight);
  }
  
  AttachInfo mAttachInfo;
  static class ThreadedRenderer {
  public static boolean isAvailable() {
  return false;
  }
  }
  class AttachInfo {
  public View mRootView;
  public boolean mHardwareAccelerationRequested;
  public int mWindowVisibility = View.VISIBLE;
  		Rect mTmpInvalRect;
  		Object mViewRequestingLayout;
  		public boolean mKeepScreenOn;
  }
  
  void onResolveDrawables(int layoutDirection) {
  }
  
  ThreadLocal sThreadLocal = new ThreadLocal();
  class ThreadLocal {
  	Rect obj;
  	Rect get() {
  		return obj;
  	}
  	
  	void set(Rect obj) {
  		this.obj = obj;
  	}
  }
  
  static class TextUtils {
  	static int getLayoutDirectionFromLocale(Locale l) {
  		return 0;
  	}
  }
  
  class ViewRootImpl {
  	boolean isInLayout() {
  		return false;
  	}
  	
  	boolean requestLayoutDuringLayout(View view) {
  		return false;
  	}
  }

	ViewRootImpl getViewRootImpl() {
		return null;
	}
	ListenerInfo mListenerInfo;
	class ListenerInfo{
		ArrayList<OnLayoutChangeListener> mOnLayoutChangeListeners;
		OnKeyListener mOnKeyListener;
		public Object clone(){
			return null;
		}
	} 
	
	class OnLayoutChangeListener{
		public void onLayoutChange(View v, int l, int t, int r, int b,int oldL,int oldT,int oldR,int oldB)
		{
		}
	}

	public int getId() {
		return mID;
	}
	public void setId(int id) {
		this.mID = id;
	}
}

	public android.content.Context getContext() {
		return new android.content.Context();
	}
	
	public boolean hasFocus() {
		return false;
	}
	public View findFocus() {
		return null;
	}
	
	public void unFocus(Object obj) {
	}
	
	public void dispatchAttachedToWindow(AttachInfo mAttachInfo2, int i) {
	}
	
	public boolean hasTransientState() {
		return false;
	}
	
	public void clearAccessibilityFocus() {
	}	
	
	public Object getAnimation() {
		return null;
	}
	public void dispatchDetachedFromWindow() {
	}
	
	public void setBackground(Drawable background) {
		mBackground = background;
	}
	
	public Drawable getBackground() {
		return mBackground;
	} 
	
	boolean hasIdentityMatrix() {
		return false;
	}
 	public void setAccessibilityDelegate(Object delegate) {
    }
    
    public Object getAccessibilityDelegate() {
    	return null;
    }
    
    public void dispatchStartTemporaryDetach() {
    }
    
    public void dispatchFinishTemporaryDetach() {
    }
    
    public void setDrawingCacheBackgroundColor(Object color) {
	}
 
 	public int getImportantForAccessibility() {
 		return 999;
 	}
 	
 	public void setImportantForAccessibility(int test) {
 	}   
 	
 	public void onStartTemporaryDetach() {
		// TODO Auto-generated method stub	
	}
	
	public boolean clearFocus() {
		return false;
	}
	
	
public static class AccessibilityNodeInfo {
public static final int ACTION_ACCESSIBILITY_FOCUS = 0;

public Object getSourceNodeId(){
return null;
}
public static int getVirtualDescendantId(Object sourceNodeId){
return 0;
}
}




public class AccessibilityNodeProvider{
	public void performAction(int virtualViewId, int actionAccessibilityFocus, Object object) {
		// TODO Auto-generated method stub
		
	}
}
	public boolean isAttachedToWindow() {
	// TODO Auto-generated method stub
	return false;
}
public AccessibilityNodeProvider getAccessibilityNodeProvider() {
	// TODO Auto-generated method stub
	return null;
}

public void requestAccessibilityFocus() {
	// TODO Auto-generated method stub
	
}
public void onFinishTemporaryDetach() {
	// TODO Auto-generated method stub
	
}
public Object getWindowToken() {
	// TODO Auto-generated method stub
	return null;
}
public boolean isDrawingCacheEnabled() {
	// TODO Auto-generated method stub
	return false;
}
public void setDrawingCacheEnabled(boolean b) {
	// TODO Auto-generated method stub
	
}
public void jumpDrawablesToCurrentState() {
	// TODO Auto-generated method stub
	
}
class RoundScrollbarRenderer {
    public RoundScrollbarRenderer(View view) {
    }
}
public static class MotionEvent{
    public static final int ACTION_DOWN  = 0;
    public static final int ACTION_UP  = 1;
    public static final int ACTION_MOVE = 2;
    public static final int ACTION_CANCEL = 3;
    public static final int ACTION_OUTSIDE = 4;
    public static final int ACTION_SCROLL = 8;
   	public static final int ACTION_BUTTON_PRESS   = 11;
    public static final int ACTION_BUTTON_RELEASE  = 12;

	private int x;
	private int y;
	private int rawX;
	private int rawY;
	private int action;
	public int getAction(){
	return action;
	}
	public void setAction(int action){
	this.action=action;
	}
	public int getX(){
	return x;
	}
	public void setX(int x){
	this.x=x;
	}
	public int getY(){
	return y;
	}
	public void setY(int y){
	this.y=y;
	}
	public int getRawX() {
		return rawX;
	}
	public void setRawX(int rawX) {
		this.rawX = rawX;
	}
	public int getRawY() {
		return rawY;
	}
	public void setRawY(int rawY) {
		this.rawY = rawY;
	}

}

public static class DragEvent{

	private int x;
	private int y;
	private int action;
	private String clipData;
	public static final int ACTION_DRAG_STARTED = 1;
    public static final int ACTION_DRAG_LOCATION = 2;
    public static final int ACTION_DROP = 3;
    public static final int ACTION_DRAG_ENDED = 4;
    public static final int ACTION_DRAG_ENTERED = 5;
    public static final int ACTION_DRAG_EXITED = 6;

	public void setClipData(String clipData) {
		this.clipData = clipData;
	}
	public int getAction() {
		return action;
	}
	public void setAction(int action) {
		this.action = action;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	public String getClipData() {
		return clipData;
	}

}

public boolean dispatchKeyEvent(KeyEvent event) {
	return false;
}
public void applyForegroundTint() {
}
public void unscheduleDrawable(Object obj) {
}

protected void drawableStateChanged(){
}
 public void drawableHotspotChanged(float x, float y) {
 }
 
public boolean hasWindowFocus() {
return false;
}


  public void setFocused(  boolean hovered){
    if (hovered) {
      if ((mPrivateFlags & PFLAG_FOCUSED) == 0) {
        mPrivateFlags|=PFLAG_FOCUSED;
        refreshDrawableState();
        onFocusChanged(true);
      }
    }
 else {
      if ((mPrivateFlags & PFLAG_FOCUSED) != 0) {
        mPrivateFlags&=~PFLAG_FOCUSED;
        refreshDrawableState();
        onFocusChanged(false);
      }
    }
  }
  public void onFocusChanged(boolean focus){
  } 
  
   public void setDragHovered(  boolean hovered){
    if (hovered) {
      if ((mPrivateFlags2 & PFLAG2_DRAG_HOVERED) == 0) {
        mPrivateFlags2|=PFLAG2_DRAG_HOVERED;
        refreshDrawableState();
        onDragHovered(true);
      }
    }
 else {
      if ((mPrivateFlags2 & PFLAG2_DRAG_HOVERED) != 0) {
        mPrivateFlags2&=~PFLAG2_DRAG_HOVERED;
        refreshDrawableState();
        onDragHovered(false);
      }
    }
  }
  public void onDragHovered(boolean focus){
  } 
  
  public void setDragCanAccept(  boolean hovered){
    if (hovered) {
      if ((mPrivateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) == 0) {
        mPrivateFlags2|=PFLAG2_DRAG_CAN_ACCEPT;
        refreshDrawableState();
        onDragCanAccept(true);
      }
    }
 else {
      if ((mPrivateFlags2 & PFLAG2_DRAG_CAN_ACCEPT) != 0) {
        mPrivateFlags2&=~PFLAG2_DRAG_CAN_ACCEPT;
        refreshDrawableState();
        onDragCanAccept(false);
      }
    }
  }
  public void onDragCanAccept(boolean focus){
  }
  
public Rect getForegroundBounds(int imageWidth, int imageHeight) {
	final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null;
	if (foreground != null) {
		//if (mForegroundInfo.mBoundsChanged) {
			mForegroundInfo.mBoundsChanged = false;
			final Rect selfBounds = mForegroundInfo.mSelfBounds;
			final Rect overlayBounds = mForegroundInfo.mOverlayBounds;
			if (mForegroundInfo.mInsidePadding) {
				selfBounds.set(0, 0, getWidth(), getHeight());
			} else {
				selfBounds.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(),
						getHeight() - getPaddingBottom());
			}
			final int ld = getLayoutDirection();
			Gravity.apply(mForegroundInfo.mGravity, imageWidth, imageHeight, selfBounds, overlayBounds, ld);
			//return overlayBounds;
		//}
		return mForegroundInfo.mOverlayBounds;
	}
	return null;
}
public void onAttachedToWindow(){
}
public class TintInfo {
	public boolean mHasTintList;
	public ColorStateList mTintList;

}
public void applyBackgroundTint() {
}

public boolean hasOnKeyListener(){
	return getOnKeyListener() != null;
}
public OnKeyListener getOnKeyListener(){
if (mListenerInfo != null) {
return mListenerInfo.mOnKeyListener;
}
return null;
}
public void invokeKeyListenerDown(int keyCode){
OnKeyListener onKeyListener=getOnKeyListener();
if (onKeyListener != null) {
KeyEvent keyEvent=new KeyEvent();
keyEvent.setAction(KeyEvent.ACTION_DOWN);
keyEvent.setKeyCode(keyCode);
onKeyListener.onKey(this,keyCode,keyEvent);
}
}

public void invokeKeyListenerUp(int keyCode){
OnKeyListener onKeyListener=getOnKeyListener();
if (onKeyListener != null) {
KeyEvent keyEvent=new KeyEvent();
keyEvent.setAction(KeyEvent.ACTION_UP);
keyEvent.setKeyCode(keyCode);
onKeyListener.onKey(this,keyCode,keyEvent);
}
private void resetPressedState() {
}
 public void sendAccessibilityEvent(int eventType) {
 }
  public void notifyViewAccessibilityStateChangedIfNeeded(int changeType) {
  }
}

